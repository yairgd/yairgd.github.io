<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Yair Gadelov Tech Blog</title><link>https://yairgd.github.io/post/</link><description>Recent content in Posts on Yair Gadelov Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 02 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yairgd.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a New Theme</title><link>https://yairgd.github.io/2014/09/creating-a-new-theme/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2014/09/creating-a-new-theme/</guid><description>Introduction This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&amp;rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&amp;rsquo;t cover using CSS to style your theme.
We&amp;rsquo;ll start with creating a new site with a very basic template.</description></item><item><title>Migrate to Hugo from Jekyll</title><link>https://yairgd.github.io/2014/03/migrate-to-hugo-from-jekyll/</link><pubDate>Mon, 10 Mar 2014 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2014/03/migrate-to-hugo-from-jekyll/</guid><description>Move static content to static Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like
▾ &amp;lt;root&amp;gt;/ ▾ images/ logo.png should become
▾ &amp;lt;root&amp;gt;/ ▾ static/ ▾ images/ logo.png Additionally, you&amp;rsquo;ll want any files that should reside at the root (such as CNAME) to be moved to static.</description></item><item><title>Simple Hello World application using qt5 for embedded Linux device.</title><link>https://yairgd.github.io/2020/04/simple-hello-world-application-using-qt5-for-embedded-linux-device./</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/04/simple-hello-world-application-using-qt5-for-embedded-linux-device./</guid><description>This post presents a simple example of how to create a qt5 application for a Linux embedded device that runs Wayland or x-server. I&amp;rsquo;m using Yocto build system. I already have a BSP for IMX8 + toolchain so. I just have to install qt5 on it. In the time that I wrote this page, I worked with sumo branch and had to do some work around over three bugs that I found during the compilation of qt5.</description></item><item><title>Debug Linux Kernel With Qemu</title><link>https://yairgd.github.io/2020/03/debug-linux-kernel-with-qemu/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/03/debug-linux-kernel-with-qemu/</guid><description>I have tried to debug the Linux kernel using GDB and a system emulator qemu. I use YOCTO and standard pokey distribution to build Linux image and kernel. I made changes to the standard .config file to support debug symbols and remove the KASLR option from the kernel
kernel config The kernel has to modify as the following:
Add debug symbols by adding this option author: CONFIG_DEBUG_INFO=y Remove KASLR definition from kernel by unset: CONFIG_RANDOMIZE_BASE.</description></item><item><title>Install Yocto and kernel development tools of IMX8</title><link>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</guid><description>The GCC toolchain and kernel installation. The purpose of this post is to show the installation process of development tools for imx8m-var-dart, which is SOM made by Variscite. Usually, a kernel, userspace applications, and toolchain built as part of a Yocto image but, for continuous development purposes, when custom kernel modules or userspace applications developed, it is more comfortable with making it stand-alone and working on it outside the Yocto image.</description></item><item><title>Linux uio driver to handle with IRQ source</title><link>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-irq-source/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-irq-source/</guid><description>This is a a driver based on UIO subsystem to handle with external IRQ source.
The driver structure References [1] https://www.kernel.org/doc/html/v4.13/driver-api/uio-howto.html</description></item><item><title>Linux char device to handle with IRQ</title><link>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</guid><description>We have an external FPGA that triggers GPIO. To handle the IRQ in userspace, it had to write a Linux chr device to control the IRQ in the kernel space and than signalize the userspace using a standard system call. Here is the simple drive:
#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt; /* printk() */#include &amp;lt;linux/moduleparam.h&amp;gt;#include &amp;lt;asm/uaccess.h&amp;gt;#include &amp;lt;asm/pgtable.h&amp;gt;#include &amp;lt;linux/fs.h&amp;gt;#include &amp;lt;linux/gfp.h&amp;gt;#include &amp;lt;linux/cdev.h&amp;gt;#include &amp;lt;linux/sched.h&amp;gt;#include &amp;lt;linux/interrupt.h&amp;gt;#include &amp;lt;linux/of_address.h&amp;gt;#include &amp;lt;linux/of_irq.h&amp;gt;#include &amp;lt;linux/of_platform.h&amp;gt; #include &amp;lt;linux/semaphore.h&amp;gt; DECLARE_WAIT_QUEUE_HEAD(hq); static int irq_num; static int x=0; //spinlock_t mLock = SPIN_LOCK_UNLOCKED; unsigned long flags; static DEFINE_SPINLOCK(mLock); static irqreturn_t fpga_irq_handle(int irq, void *dev_id) { wake_up(&amp;amp;hq); // printk(KERN_DEBUG &amp;#34;Interrupt\n&amp;#34;); return IRQ_HANDLED; } static ssize_t fpga_read(struct file *file, char __user *buf,size_t count,loff_t *ppos) { wait_event(hq,x); return 0; } static struct file_operations fpga_fops = { .</description></item><item><title>Linux module magic info</title><link>https://yairgd.github.io/2020/02/linux-module-magic-info/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-magic-info/</guid><description>Sometimes we want to build a module separate from the kernel. When the kernel is built, it generates a magic number, which probably depends on compiler version, kernel version, git source revision, etc. Time is also probably part of this magic number, since the kernel may build with the same parameters but with a different timestamp, it will have a different magic number, and then we will get this message when we try to insert it:</description></item><item><title>Linux core isolation</title><link>https://yairgd.github.io/2020/02/linux-core-isolation/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-core-isolation/</guid><description>I have a real-time task that needed to run periodically at a constant rate - a continuous IRQ drives it. Just running this task on a multithreaded environment can cause it to run in different timing values. When the system runs on stress (using stress utility) the system is not a response to all IRQ requests. A possible solution to this problem is to use Linux core isolation. In this case, we assign a specific core for the task, and the Linux kernel is getting out from the SMP balancing, and this core can use for a particular job with minimal interrupts.</description></item><item><title>Linux module to disassemble code in the Linux kernel.</title><link>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</guid><description>A simple module to disassembly memory using a Linux kernel module. This module is based on Zydis and integrated into this module. Also, there is a userspace application to demonstrate the Zydis library on a test function in user space and disassembly of the same c function at the kernel space. Also can dissemble internal c functions of the kernel like printk, kmalloc etc&amp;rsquo;.
Module structure The module allows two interfaces from userspace:</description></item><item><title>Color transformation from Bayer to RGB</title><link>https://yairgd.github.io/2020/02/color-transformation-from-bayer-to-rgb/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/color-transformation-from-bayer-to-rgb/</guid><description>A Bayer filter mosaic is a color filter array (CFA) for arranging RGB color filters on a square grid of photosensors. Its particular arrangement of color filters is used in most single-chip digital image sensors used in digital cameras, camcorders, and scanners to create a color image. The filter pattern is 50% green, 25% red and 25% blue - see here. Color conversion algorithm The conversion algorithm is based on simple linear interpolation of pixels to find the missing value.</description></item><item><title>My First Post</title><link>https://yairgd.github.io/2020/02/my-first-post/</link><pubDate>Mon, 10 Feb 2020 00:17:54 +0200</pubDate><guid>https://yairgd.github.io/2020/02/my-first-post/</guid><description>It is My first Hugo post. I decided to work with Hugo after I had an experience with word press. For me, writing documents in Markdown format and using GitHub to manage my files, tags, and categories instead of using MySQL database is much easier to manage and deploy. To learn how to create such a blog in Hugo, you can try this blog,
diagram Learn how to plot the kinds of figures.</description></item><item><title>(Hu)go Template Primer</title><link>https://yairgd.github.io/2014/04/hugo-template-primer/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2014/04/hugo-template-primer/</guid><description>Hugo uses the excellent Go html/template library for its template engine. It is an extremely lightweight engine that provides a very small amount of logic. In our experience that it is just the right amount of logic to be able to create a good static website. If you have used other template systems from different languages or frameworks you will find a lot of similarities in Go templates.
This document is a brief primer on using Go templates.</description></item><item><title>Getting Started with Hugo</title><link>https://yairgd.github.io/2014/04/getting-started-with-hugo/</link><pubDate>Wed, 02 Apr 2014 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2014/04/getting-started-with-hugo/</guid><description>Step 1. Install Hugo Go to Hugo releases and download the appropriate version for your OS and architecture.
Save it somewhere specific as we will be using it in the next step.
More complete instructions are available at Install Hugo
Step 2. Build the Docs Hugo has its own example site which happens to also be the documentation site you are reading right now.
Follow the following steps:
Clone the Hugo repository Go into the repo Run hugo in server mode and build the docs Open your browser to http://localhost:1313 Corresponding pseudo commands:</description></item></channel></rss>