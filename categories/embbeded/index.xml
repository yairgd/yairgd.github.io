<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>embbeded on Yair Gadelov Tech Blog</title><link>https://yairgd.github.io/categories/embbeded/</link><description>Recent content in embbeded on Yair Gadelov Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yairgd.github.io/categories/embbeded/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux uio driver to handle with IRQ source</title><link>https://yairgd.github.io/posts/2020/02/linux-uio-driver-to-handle-with-irq-source/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/posts/2020/02/linux-uio-driver-to-handle-with-irq-source/</guid><description>This is a a driver based on UIO subsystem to handle with external IRQ source.
The driver structure References [1] https://www.kernel.org/doc/html/v4.13/driver-api/uio-howto.html
[2] http://fpga.org/2013/05/28/how-to-design-and-access-a-memory-mapped-device-part-two
[3] https://elinux.org/images/b/b0/Uio080417celfelc08.pdf
[4] https://www.osadl.org/fileadmin/dam/rtlws/12/Koch.pdf</description></item><item><title>Linux char device to handle with IRQ</title><link>https://yairgd.github.io/posts/2020/02/linux-char-device-to-handle-with-irq/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/posts/2020/02/linux-char-device-to-handle-with-irq/</guid><description>We have an external FPGA that triggers GPIO. To handle the IRQ in userspace, it had to write a Linux chr device to control the IRQ in the kernel space and than signalize the userspace using a standard system call. Here is the simple drive:
#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt; /* printk() */#include &amp;lt;linux/moduleparam.h&amp;gt;#include &amp;lt;asm/uaccess.h&amp;gt;#include &amp;lt;asm/pgtable.h&amp;gt;#include &amp;lt;linux/fs.h&amp;gt;#include &amp;lt;linux/gfp.h&amp;gt;#include &amp;lt;linux/cdev.h&amp;gt;#include &amp;lt;linux/sched.h&amp;gt;#include &amp;lt;linux/interrupt.h&amp;gt;#include &amp;lt;linux/of_address.h&amp;gt;#include &amp;lt;linux/of_irq.h&amp;gt;#include &amp;lt;linux/of_platform.h&amp;gt; #include &amp;lt;linux/semaphore.h&amp;gt; DECLARE_WAIT_QUEUE_HEAD(hq); static int irq_num; static int x=0; //spinlock_t mLock = SPIN_LOCK_UNLOCKED; unsigned long flags; static DEFINE_SPINLOCK(mLock); static irqreturn_t fpga_irq_handle(int irq, void *dev_id) { wake_up(&amp;amp;hq); // printk(KERN_DEBUG &amp;#34;Interrupt\n&amp;#34;); return IRQ_HANDLED; } static ssize_t fpga_read(struct file *file, char __user *buf,size_t count,loff_t *ppos) { wait_event(hq,x); return 0; } static struct file_operations fpga_fops = { .</description></item><item><title>Linux module magic info</title><link>https://yairgd.github.io/posts/2020/02/linux-module-magic-info/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/posts/2020/02/linux-module-magic-info/</guid><description>Sometimes we want to build a module separate from the kernel. When the kernel is built, it generates a magic number, which probably depends on compiler version, kernel version, git source revision, etc. Time is also probably part of this magic number, since the kernel may build with the same parameters but with a different timestamp, it will have a different magic number, and then we will get this message when we try to insert it:</description></item><item><title>Linux core isolation</title><link>https://yairgd.github.io/posts/2020/02/linux-core-isolation/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/posts/2020/02/linux-core-isolation/</guid><description>I have a real-time task that needed to run periodically at a constant rate - a continuous IRQ drives it. Just running this task on a multithreaded environment can cause it to run in different timing values. When the system runs on stress (using stress utility) the system is not a response to all IRQ requests. A possible solution to this problem is to use Linux core isolation. In this case, we assign a specific core for the task, and the Linux kernel is getting out from the SMP balancing, and this core can use for a particular job with minimal interrupts.</description></item></channel></rss>