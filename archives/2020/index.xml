<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020 on My Tech Blog</title><link>https://yairgd.github.io/archives/2020/</link><description>Recent content in 2020 on My Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 24 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yairgd.github.io/archives/2020/index.xml" rel="self" type="application/rss+xml"/><item><title>Install Yocto and kernel development tools of IMX8</title><link>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</guid><description>The GCC toolchain and kernel installation. The purpose of this post is to show the installation process of development tools for imx8m-var-dart, which is SOM made by Variscite. Usually, a kernel, userspace applications, and toolchain built as part of a Yocto image but, for continuous development purposes, when custom kernel modules or userspace applications developed, it is more comfortable with making it stand-alone and working on it outside the Yocto image.</description></item><item><title>Linux uio driver to handle with external IRQ</title><link>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-external-irq/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-external-irq/</guid><description>Linux uio driver to handle with external IRQ References [1] https://www.kernel.org/doc/html/v4.13/driver-api/uio-howto.html</description></item><item><title>Linux char device to handle with IRQ</title><link>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</guid><description>Linux chr device to handle with external IRQ We have an external FPGA that triggers GPIO. To handle the IRQ in userspace, it had to write a Linux chr device to control the IRQ in the kernel space and than signalize the userspace using a standard system call.
Here is the simple drive:
#include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/kernel.h&amp;gt; /* printk() */ #include &amp;lt;linux/moduleparam.h&amp;gt; #include &amp;lt;asm/uaccess.h&amp;gt; #include &amp;lt;asm/pgtable.h&amp;gt; #include &amp;lt;linux/fs.h&amp;gt; #include &amp;lt;linux/gfp.</description></item><item><title>Linux module magic info</title><link>https://yairgd.github.io/2020/02/linux-module-magic-info/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-magic-info/</guid><description>Change module magic info Sometimes we want to build a module separate from the kernel. When the kernel is built, it generates a magic number, which probably depends on compiler version, kernel version, git source revision, etc. Time is also probably part of this magic number, since the kernel may build with the same parameters but with a different timestamp, it will have a different magic number, and then we will get this message when we try to insert it:</description></item><item><title>Linux core isolation to have a close RT performance.</title><link>https://yairgd.github.io/2020/02/linux-core-isolation-to-have-a-close-rt-performance./</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-core-isolation-to-have-a-close-rt-performance./</guid><description>Linux core isolation I have a real-time task that needed to run periodically at a constant rate at a constant time each time. Just running this task on a multithreaded environment can cause it to run in different timing values. A possible solution to this problem is to use Linux core isolation. In this case, we assign a specific core for the task, and the Linux kernel is getting out from the SMP balancing and hat core cand use for a specific task with minimal interrupts.</description></item><item><title>Linux module to disassemble code in the Linux kernel.</title><link>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</guid><description>disa A simple module to disassembly memory using a Linux kernel module. This module is based on Zydis and integrated into this module. Also, there is a userspace application to demonstrate the Zydis library on a test function in user space and disassembly of the same c function at the kernel space. Also can dissemble internal c functions of the kernel like printk, kmalloc etc&amp;rsquo;.
Module structure The module allows two interfaces from userspace: * Using kernel parameters API: This part of the module demonstrates the use of module parameters API to control the module.</description></item><item><title>Bayer Image to RGB</title><link>https://yairgd.github.io/2020/02/bayer-image-to-rgb/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/bayer-image-to-rgb/</guid><description>Color transformation from Bayer to RGB A Bayer filter mosaic is a color filter array (CFA) for arranging RGB color filters on a square grid of photosensors. Its particular arrangement of color filters is used in most single-chip digital image sensors used in digital cameras, camcorders, and scanners to create a color image. The filter pattern is 50% green, 25% red and 25% blue - see here.
Color conversion algorithm Implemantation Implementation using python including that modules: matplotlib, numpy,cv2.</description></item><item><title>My First Post</title><link>https://yairgd.github.io/2020/02/my-first-post/</link><pubDate>Mon, 10 Feb 2020 00:17:54 +0200</pubDate><guid>https://yairgd.github.io/2020/02/my-first-post/</guid><description> first post This is My first Hugo post. I decided to work with Hugo after I had an experience with word press. For me, writing documents in Markdown format and using GitHub to manage my files, tags, and categories instead of using MySQL database is much easier to manage and deploy. To learn how to create such blog in Hugo you can try this blog.Â </description></item></channel></rss>