<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2020 on Yair Gadelov Tech Blog</title><link>https://yairgd.github.io/archives/2020/</link><description>Recent content in 2020 on Yair Gadelov Tech Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 17 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://yairgd.github.io/archives/2020/index.xml" rel="self" type="application/rss+xml"/><item><title>Compile Linux kernel for zynq</title><link>https://yairgd.github.io/2020/10/compile-linux-kernel-for-zynq/</link><pubDate>Sat, 17 Oct 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/10/compile-linux-kernel-for-zynq/</guid><description>In previous post I shoed how to build and install Linux system on microzed board. When adapting the kernel &amp;amp; u-boot to the system, it is better to build and test it separately outside the yocto build. I use yocto&amp;rsquo;s kernel &amp;amp; u-boot sources and its SDK for the custom build.
build the kernel To enable SDK , just type the following command.
. /opt/poky/3.0.3/environment-setup-cortexa9t2hf-neon-poky-linux-gnueabi This script will define a series of enviement vaiables like $CC &amp;amp; $CXX that needed for the build.</description></item><item><title>Eclipse with CMake project on windows</title><link>https://yairgd.github.io/2020/09/eclipse-with-cmake-project-on-windows/</link><pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/09/eclipse-with-cmake-project-on-windows/</guid><description>CMake is a powerful tool to manage c/c++ projects, and I prefer to use it in on my embedded projects also. Usually, the MCU has some communication with other processors (usually PC), and CMake also allows easy integration between both projects: MCU and HOST. For example, a shared source code that simultaneously able to recompile in both processors when any change occurs in these shared files.
Usually, I work in a Linux environment in the terminal where everything is installed correctly in its place, and things work great.</description></item><item><title>install linux on microzed board</title><link>https://yairgd.github.io/2020/08/install-linux-on-microzed-board/</link><pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/08/install-linux-on-microzed-board/</guid><description>The microzed development board has Xilinx zynq7000 chip. It has an application process unit with cortex a9 and FPGA fabric. The board also contains interfaces like SDIO and QSPI. I want to install Linux on it directly with yocto and without petalinux, which runs yocto behind the scene, so I tried to eliminate the need to use it. Why do so?
It is interesting, and I have a lot of experience with yocto and it very easy to work with its script once you know it easy porting to other processors: IMX, stm32Mp157, etc&amp;rsquo; using build tools like CMake,Autotools, and yocto scripts make it very easy to port SW between different processors.</description></item><item><title>Custom opkg repository</title><link>https://yairgd.github.io/2020/06/custom-opkg-repository/</link><pubDate>Thu, 18 Jun 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/06/custom-opkg-repository/</guid><description>The post presenst simple example to create opkg repository to upgrade embbded linux systems using nginx server. The opkg pakcge should be installed as part of the image furing the first instalation. To add opkg to yocto image type type folloing line in file conf/local.conf
IMAGE_INSTALL_append = &amp;#34; opkg \ &amp;#34; downlad and install opkg utils:
git clone git://git.yoctoproject.org/opkg-utils and create Packages.gz file:
cd /path-to-yocto-build/build/tmp/deploy/ipk ~/opkg-utils/opkg-make-index . &amp;gt; Packages.gz install nginx I haved used gentoo system , so inorder to install nginx on gentoo type:</description></item><item><title>Kalman filter and pair trading</title><link>https://yairgd.github.io/2020/05/kalman-filter-and-pair-trading/</link><pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/05/kalman-filter-and-pair-trading/</guid><description>Pair trading is a type of cointegration approach to statistical arbitrage trading strategy in which usually a pair of stocks are tcraded in a market-neutral strategy, i.e. it doesnâ€™t matter whether the market is trending upwards or downwards, the two open positions for each stock hedge against each other. The key challenges in pairs trading are to:
Choose a pair which will give you good statistical arbitrage opportunities over time Choose the entry/exit points One of the challenges with the pair trading is that cointegration relationships are seldom static.</description></item><item><title>Simple Hello World application using qt5 for embedded Linux device.</title><link>https://yairgd.github.io/2020/04/simple-hello-world-application-using-qt5-for-embedded-linux-device./</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/04/simple-hello-world-application-using-qt5-for-embedded-linux-device./</guid><description>This post presents a simple example of how to create a qt5 application for a Linux embedded device that runs Wayland or x-server. I&amp;rsquo;m using Yocto build system. I already have a BSP for IMX8 + toolchain so. I just have to install qt5 on it. In the time that I wrote this page. See here a reference to use Yocto project.
bug workaroud I worked with sumo branch and had to do some work around over three bugs that I found during the compilation of qt5.</description></item><item><title>Debug Linux Kernel With Qemu</title><link>https://yairgd.github.io/2020/03/debug-linux-kernel-with-qemu/</link><pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/03/debug-linux-kernel-with-qemu/</guid><description>I have tried to debug the Linux kernel using GDB and a system emulator qemu. I use YOCTO and standard pokey distribution to build Linux image and kernel. I made changes to the standard .config file to support debug symbols and remove the KASLR option from the kernel
kernel config The kernel has to modify as the following:
Build a Linux kernel with debug symbols by set: CONFIG_DEBUG_INFO=y Remove KASLR definition from the Linux kernel by unset: CONFIG_RANDOMIZE_BASE.</description></item><item><title>Install Yocto and kernel development tools of IMX8</title><link>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/install-yocto-and-kernel-development-tools-of-imx8/</guid><description>The GCC toolchain and kernel installation. The purpose of this post is to show the installation process of development tools for imx8m-var-dart, which is SOM made by Variscite. When using yocto, the kernel, userspace applications, and toolchain are part of the build. Still, when developing kernel modules, device tree changes, or userspace applications, it is more practical to make a standalone kernel build and to work on it outside the yocto.</description></item><item><title>Linux uio driver to handle with IRQ source</title><link>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-irq-source/</link><pubDate>Mon, 24 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-uio-driver-to-handle-with-irq-source/</guid><description>This is a a driver based on UIO subsystem to handle with external IRQ source.
The driver structure References [1] https://www.kernel.org/doc/html/v4.13/driver-api/uio-howto.html
[2] http://fpga.org/2013/05/28/how-to-design-and-access-a-memory-mapped-device-part-two
[3] https://elinux.org/images/b/b0/Uio080417celfelc08.pdf
[4] https://www.osadl.org/fileadmin/dam/rtlws/12/Koch.pdf</description></item><item><title>Linux char device to handle with IRQ</title><link>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-char-device-to-handle-with-irq/</guid><description>We have an external FPGA that triggers GPIO. To handle the IRQ in userspace, it had to write a Linux chr device to control the IRQ in the kernel space and than signalize the userspace using a standard system call. Here is the simple drive:
#include &amp;lt;linux/module.h&amp;gt;#include &amp;lt;linux/kernel.h&amp;gt; /* printk() */#include &amp;lt;linux/moduleparam.h&amp;gt;#include &amp;lt;asm/uaccess.h&amp;gt;#include &amp;lt;asm/pgtable.h&amp;gt;#include &amp;lt;linux/fs.h&amp;gt;#include &amp;lt;linux/gfp.h&amp;gt;#include &amp;lt;linux/cdev.h&amp;gt;#include &amp;lt;linux/sched.h&amp;gt;#include &amp;lt;linux/interrupt.h&amp;gt;#include &amp;lt;linux/of_address.h&amp;gt;#include &amp;lt;linux/of_irq.h&amp;gt;#include &amp;lt;linux/of_platform.h&amp;gt; #include &amp;lt;linux/semaphore.h&amp;gt; DECLARE_WAIT_QUEUE_HEAD(hq); static int irq_num; static int x=0; //spinlock_t mLock = SPIN_LOCK_UNLOCKED; unsigned long flags; static DEFINE_SPINLOCK(mLock); static irqreturn_t fpga_irq_handle(int irq, void *dev_id) { wake_up(&amp;amp;hq); // printk(KERN_DEBUG &amp;#34;Interrupt\n&amp;#34;); return IRQ_HANDLED; } static ssize_t fpga_read(struct file *file, char __user *buf,size_t count,loff_t *ppos) { wait_event(hq,x); return 0; } static struct file_operations fpga_fops = { .</description></item><item><title>Linux module magic info</title><link>https://yairgd.github.io/2020/02/linux-module-magic-info/</link><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-magic-info/</guid><description>Sometimes we want to build a module separate from the kernel. When the kernel is built, it generates a magic number, which probably depends on compiler version, kernel version, git source revision, etc. Time is also probably part of this magic number, since the kernel may build with the same parameters but with a different timestamp, it will have a different magic number, and then we will get this message when we try to insert it:</description></item><item><title>Linux core isolation</title><link>https://yairgd.github.io/2020/02/linux-core-isolation/</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-core-isolation/</guid><description>I have a real-time task that needed to run periodically at a constant rate - a continuous IRQ drives it. Just running this task on a multithreaded environment can cause it to run in different timing values. When the system runs on stress (using stress utility) the system is not a response to all IRQ requests. A possible solution to this problem is to use Linux core isolation. In this case, we assign a specific core for the task, and the Linux kernel is getting out from the SMP balancing, and this core can use for a particular job with minimal interrupts.</description></item><item><title>Linux module to disassemble code in the Linux kernel.</title><link>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</link><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./</guid><description>A simple module to disassembly memory using a Linux kernel module. This module is based on Zydis and integrated into this module. Also, there is a userspace application to demonstrate the Zydis library on a test function in user space and disassembly of the same c function at the kernel space. Also can dissemble internal c functions of the kernel like printk, kmalloc etc&amp;rsquo;.
Module structure The module allows two interfaces from userspace:</description></item><item><title>Color transformation from Bayer to RGB</title><link>https://yairgd.github.io/2020/02/color-transformation-from-bayer-to-rgb/</link><pubDate>Mon, 17 Feb 2020 00:00:00 +0000</pubDate><guid>https://yairgd.github.io/2020/02/color-transformation-from-bayer-to-rgb/</guid><description>A Bayer filter mosaic is a color filter array (CFA) for arranging RGB color filters on a square grid of photosensors. Its particular arrangement of color filters is used in most single-chip digital image sensors used in digital cameras, camcorders, and scanners to create a color image. The filter pattern is 50% green, 25% red and 25% blue - see here. Color conversion algorithm The conversion algorithm is based on simple linear interpolation of pixels to find the missing value.</description></item><item><title>My First Post</title><link>https://yairgd.github.io/2020/02/my-first-post/</link><pubDate>Mon, 10 Feb 2020 00:17:54 +0200</pubDate><guid>https://yairgd.github.io/2020/02/my-first-post/</guid><description>It is My first Hugo post. I decided to work with Hugo after I had an experience with word press. For me, writing documents in Markdown format and using GitHub to manage my files, tags, and categories instead of using MySQL database is much easier to manage and deploy. To learn how to create such a blog in Hugo, you can try this blog,
diagram Learn how to plot the kinds of figures.</description></item></channel></rss>