<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=UA-158845844-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-158845844-1');</script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery-cookiebar/1.0.5/jquery.cookiebar.min.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/jquery-cookiebar/1.0.5/jquery.cookiebar.css><script type=text/javascript>$(document).ready(function(){$.cookieBar({fixed:true,acceptOnScroll:600,policyURL:'/privacy-policy/',policyButton:true,policyText:'Privacy Policy',expireDays:45});});</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body);></script><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>linux</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><link href="https://fonts.googleapis.com/css?family=Open+Sans" rel=stylesheet><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css><link rel=stylesheet href=https://yairgd.github.io/css/blog.css><link href=https://yairgd.github.io/tags/linux/index.xml rel=alternate type=application/rss+xml title="Yair Gadelov Tech Blog"><link href=https://yairgd.github.io/tags/linux/index.xml rel=feed type=application/rss+xml title="Yair Gadelov Tech Blog"></head><body><nav class="navbar is-fixed-top" role=navigation aria-label="main navigation"><div class=navbar-brand><a class=navbar-item href=https://yairgd.github.io/>Home</a>
<a class=navbar-item href=/pages/about>About</a>
<a class=navbar-item href=/blog>Blog</a>
<a class=navbar-item href=/pages/cv>CV</a>
<a class=navbar-item href=/projects>Projects</a>
<a class=navbar-item href=/pages/search>Search</a></div></nav><section class="hero is-info is-medium"><div class=hero-body style=background-image:url(https://yairgd.github.io/img/bg-blog1.jpg)><div class="container has-text-centered"><br><h1 class="title is-size-1">#linux</h1></div></div></section><div class=container><div class=section><div class=columns><div class="column is-9"><div class="tile is-child box"><div class=content><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2021/01/linux-gadget-device/>Linux Gadget Device</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at January 19, 2021 &#183;
<i class="far fa-clock"></i>&nbsp;4 min read</p><p>This post is an example how to make a USB device from a linux embbeded mahcine where is can controlled by any HOST. From Linux documention:
Most Linux developers will not be able to use this API, since they have USB host hardware in a PC, workstation, or server. Linux users with embedded systems are more likely to have USB peripheral hardware. To distinguish drivers running inside such hardware from the more familiar Linux “USB device drivers”, which are host side proxies for the real USB devices, a different term is used: the drivers inside the peripherals are “USB gadget drivers”....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/11/install-embedded-linux-toolchain-on-windows/>Install embedded Linux toolchain on windows</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at November 25, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;2 min read</p><p>The toolchain for embedded Linux should be matched for the target image, and that is why we can&rsquo;t just find and download it from somewhere. Therefore, we should be it. This is a tutorial on how to build and install YOCTO SDK on a windows machine. This allows developing embedded Linux on windows using eclipse or even visual studio.
Setup YOCTO build If you already have a YOCTO build, you need to make the following simple steps:...</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/10/simple-openamp-application-for-stm32mp157/>Simple OpenAMP application for stm32mp157</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at October 25, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;3 min read</p><p>The stm32mp157 is SOC from STMicroelectronics , and it has within it a dual-core Cortex-A7 MPU and Cortex-M4 MCU. The Cortex-A7 is the application processor that operates Linux, and the Cortex-m4 runs RTOS or bare-metal application. The Cortex-M4 can be used for real-time tasks, such as creating a periodic and accurate control signal without jitter. In this kind of application, the Cortex-aA7 will run the master application and control the application of the Cortex-m4 using RPMsg Messaging Protocol....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/10/compile-linux-kernel-for-zynq/>Compile Linux kernel for zynq</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at October 17, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;2 min read</p><p>In previous post I shoed how to build and install Linux system on microzed board. When one tries to modify the kernel & u-boot, it is better to build and test it separately outside the Yocto build. I use Yocto&rsquo;s kernel & u-boot sources and its SDK for the custom build.
build the kernel To enable SDK , just type the following command.
. /opt/poky/3.0.3/environment-setup-cortexa9t2hf-neon-poky-linux-gnueabi This script will define a series of enviement variables like $CC & $CXX that needed for the build....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/04/simple-hello-world-application-using-qt5-for-embedded-linux-device./>Simple Hello World application using qt5 for embedded Linux device.</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at April 1, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;2 min read</p><p>This post presents a simple example of how to create a qt5 application for a Linux embedded device that runs Wayland or x-server. I&rsquo;m using Yocto build system. I already have a BSP for IMX8 + toolchain so. I just have to install qt5 on it. In the time that I wrote this page. See here a reference to use Yocto project.
bug workaroud I worked with sumo branch and had to do some work around over three bugs that I found during the compilation of qt5....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/03/debug-linux-kernel-with-qemu/>Debug Linux Kernel With Qemu</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at March 18, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;2 min read</p><p>I have tried to debug the Linux kernel using GDB and a system emulator qemu. I use YOCTO and standard pokey distribution to build Linux image and kernel. I made changes to the standard .config file to support debug symbols and remove the KASLR option from the kernel
kernel config The kernel has to modify as the following:
Build a Linux kernel with debug symbols by set: CONFIG_DEBUG_INFO=y Remove KASLR definition from the Linux kernel by unset: CONFIG_RANDOMIZE_BASE....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/02/linux-uio-driver-to-handle-with-irq-source./>Linux UIO driver to handle with IRQ source.</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at February 24, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;6 min read</p><p>The Userspace I/O framework (UIO) is part of the Linux kernel and allows device drivers to be written almost entirely in userspace. UIO is suitable for hardware that does not fit into other kernel subsystems (Like special HW like FPGA) and allowing the programmer to write most of the driver in userspace using all standard application programming tools and libraries. This greatly simplifies the development, maintenance, and distribution of device drivers for this kind of hardware....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/02/linux-char-device-to-handle-with-irq/>Linux char device to handle with IRQ</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at February 20, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;2 min read</p><p>We have an external FPGA that triggers GPIO. To handle the IRQ in userspace, it had to write a Linux chr device to control the IRQ in the kernel space and than signalize the userspace using a standard system call. Here is the simple drive:
#include &lt;linux/module.h>#include &lt;linux/kernel.h> /* printk() */#include &lt;linux/moduleparam.h>#include &lt;asm/uaccess.h>#include &lt;asm/pgtable.h>#include &lt;linux/fs.h>#include &lt;linux/gfp.h>#include &lt;linux/cdev.h>#include &lt;linux/sched.h>#include &lt;linux/interrupt.h>#include &lt;linux/of_address.h>#include &lt;linux/of_irq.h>#include &lt;linux/of_platform.h> #include &lt;linux/semaphore.h> DECLARE_WAIT_QUEUE_HEAD(hq); static int irq_num; static int x=0; //spinlock_t mLock = SPIN_LOCK_UNLOCKED; unsigned long flags; static DEFINE_SPINLOCK(mLock); static irqreturn_t fpga_irq_handle(int irq, void *dev_id) { wake_up(&hq); // printk(KERN_DEBUG "Interrupt\n"); return IRQ_HANDLED; } static ssize_t fpga_read(struct file *file, char __user *buf,size_t count,loff_t *ppos) { wait_event(hq,x); return 0; } static struct file_operations fpga_fops = { ....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/02/linux-module-magic-info/>Linux module magic info</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at February 20, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;3 min read</p><p>Sometimes we want to build a module separate from the kernel. When the kernel is built, it generates a magic number, which probably depends on compiler version, kernel version, git source revision, etc. Time is also probably part of this magic number, since the kernel may build with the same parameters but with a different timestamp, it will have a different magic number, and then we will get this message when we try to insert it:...</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/02/linux-core-isolation/>Linux core isolation</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at February 18, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;1 min read</p><p>I have a real-time task that needed to run periodically at a constant rate - a continuous IRQ drives it. Just running this task on a multithreaded environment can cause it to run in different timing values. When the system runs on stress (using stress utility) the system is not a response to all IRQ requests. A possible solution to this problem is to use Linux core isolation. In this case, we assign a specific core for the task, and the Linux kernel is getting out from the SMP balancing, and this core can use for a particular job with minimal interrupts....</p></div></div></article><br><article class=media><div class=media-content><div class=content><p class="title is-4"><a href=/2020/02/linux-module-to-disassemble-code-in-the-linux-kernel./>Linux module to disassemble code in the Linux kernel.</a></p><p class="subtitle is-size-6 has-text-grey-light">Published at February 18, 2020 &#183;
<i class="far fa-clock"></i>&nbsp;3 min read</p><p>A simple module to disassembly memory using a Linux kernel module. This module is based on Zydis and integrated into this module. Also, there is a userspace application to demonstrate the Zydis library on a test function in user space and disassembly of the same c function at the kernel space. Also can dissemble internal c functions of the kernel like printk, kmalloc etc&rsquo;.
Module structure The module allows two interfaces from userspace:...</p></div></div></article><br></div></div></div><div class="column is-3"><div class=card><div class=card-content><h1 class="title is-5">Categories</h1><div class=tags><span class=tag><a href=https://yairgd.github.io/categories/algorithm>algorithm</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/development>development</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/embedded>embedded</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/golang>golang</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/linux>linux</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/python>python</a></span>
<span class=tag><a href=https://yairgd.github.io/categories/qt5>qt5</a></span></div></div></div><br><div class=card><div class=card-content><h1 class="title is-5">Tags</h1><div class=tags><span class=tag><a href=https://yairgd.github.io/tags/bayer>bayer</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/computer-vision>computer-vision</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/cypress.>cypress.</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/development>development</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/eclipse>eclipse</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/embedded>embedded</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/go>go</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/golang>golang</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/hugo>hugo</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/kalman-filter>kalman-filter</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/kernel>kernel</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/linux>linux</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/openocd>openocd</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/opkg>opkg</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/qt5>qt5</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/rgb>rgb</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/rt>rt</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/statstical-abitrage>statstical-abitrage</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/stm32>stm32</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/templates>templates</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/themes>themes</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/usb>usb</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/yocto>yocto</a></span>
<span class=tag><a href=https://yairgd.github.io/tags/zynq>zynq</a></span></div></div></div><br><div class=card><div class=card-content><h1 class="title is-5">Recent posts</h1><h1><a href=https://yairgd.github.io/2021/01/linux-gadget-device/>Linux Gadget Device</a></h1><time class="has-text-grey-light is-size-7">19 January 2021</time><h1><a href=https://yairgd.github.io/2020/11/install-embedded-linux-toolchain-on-windows/>Install embedded Linux toolchain on windows</a></h1><time class="has-text-grey-light is-size-7">25 November 2020</time><h1><a href=https://yairgd.github.io/2020/11/debugging-of-cypress-psoc6-in-linux-terminal./>Debugging of cypress psoc6 in Linux terminal.</a></h1><time class="has-text-grey-light is-size-7">5 November 2020</time><h1><a href=https://yairgd.github.io/2020/10/simple-openamp-application-for-stm32mp157/>Simple OpenAMP application for stm32mp157</a></h1><time class="has-text-grey-light is-size-7">25 October 2020</time><h1><a href=https://yairgd.github.io/2020/10/compile-linux-kernel-for-zynq/>Compile Linux kernel for zynq</a></h1><time class="has-text-grey-light is-size-7">17 October 2020</time></div></div><br><br><div class=card><div class=card-content><h1 class="title is-5">Archives</h1><a href=https://yairgd.github.io/archives/2021>2021</a> (1)<br><a href=https://yairgd.github.io/archives/2020>2020</a> (18)<br><a href=https://yairgd.github.io/archives/2014>2014</a> (4)<br></div></div></div></div></div></div><footer class="footer has-background-grey-darker has-text-white"><div class="content has-text-centered"><p><span class="icon is-large"><a href="https://m.facebook.com/yair.gadelov?ref=bookmarks" class=mysocial rel=me><i class="fab fa-facebook fa-3x"></i></a></span>&nbsp;&nbsp;
<span class="icon is-large"><a href=https://www.linkedin.com/mwlite/in/yair-gadelov-1972ab17/ class=mysocial rel=me><i class="fab fa-linkedin fa-3x"></i></a></span>&nbsp;&nbsp;
<span class="icon is-large"><a href=https://github.com/yairgd/ class=mysocial rel=me><i class="fab fa-github fa-3x"></i></a></span>&nbsp;&nbsp;<br><br>Copyright &copy; Yair Gadelov Tech Blog 2021 - Theme by <a href=https://jeffprod.com class=mysocial>JeffProd.com</a>
- <a class=mysocial href=https://yairgd.github.io/about>About</a><br></p></div></footer><script defer src=https://use.fontawesome.com/releases/v5.1.0/js/all.js></script></body></html>